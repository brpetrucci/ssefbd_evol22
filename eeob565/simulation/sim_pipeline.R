#######################################
##        Macroevolution (EEOB 565)  ##
##      BiSSE + FBD Simulation Study ##
##        Bruno do Rosario Petrucci  ##
#######################################

### 
# packages required

# devtools 
suppressMessages(library(devtools))

# paleobuddy - need to remember to be in dev_traits branch
suppressMessages(library(paleobuddy))

# APE (for saving trees)
library(ape)

# readr (for write_tsv)
library(readr)

###### currently a copy of past simulation pipeline, need to edit everything

###
# simulation pipeline settings:
# Number of traits: 2
# Trait evolution 1: Brownian Motion
  # X0: 0
  # sigma2: from fitting a lognormal distribution to extant trait data
# Trait evolution 2: BiSSE
  # states: c(0, 1)
  # X0: 0
  # Transition rates: from fitting mean and variance to extant trait data,
  # and varying sum (0.025, 0.05, 0.1)
# duration of ME: 1, 5 and 10 my
# duration of RE: same
# rho: 0.5 (MLE from calibration data)
# mu_bg: 0.12 (within bounds from literature, expected 35 species by 34my)
# mu_me from expected pruning 0.5, 0.75, 0.9
# lambda_bg: 0.225 (same as mu_bg)
# lambda_re from expected recovery 1, 1.25 and 1.5 * species during ME
  # all of these expected (exp value of trait -> exp value
  # of function of trait -> exp value of rate)
# nExp: 200
# nFinal: between one quarter and 3 times the expected
# nExtant: at least 5 extant species

###
# set up the baseline simulation settings

# expected number of total (living + extinct) species
nExp <- 200

# minimum and maximum number of species
nMin <- nExp / 4
nMax <- nExp * 2

# interval of accepted species 
nFinal <- c(nMin, nMax)

# interval of accepted extant species
nExtant <- c(5, Inf)

# calibration values
lambda_bg <- 0.225

mu_bg <- 0.12

rho <- 0.5

# number of expected species at the beginning of the ME
nME <- 35

# mass extinction event starting time
meStart <- log(nME) / (lambda_bg - mu_bg)

# mass extinction duration
meDur <- 5

# variations we want to test
meDurChange <- c(10, 1)

# recovery starting time
reStart <- meStart + meDur

# recovery duration
reDur <- 5

# variations we want to test
reDurChange <- c(10, 1)

# ME intensity
meInt <- 0.75

# variations we want to test
meIntChange <- c(0.9, 0.5)

# ME rate
# such that we expect meInt * number alive at meStart to be alive
# at the end of the ME
mu_me <- lambda_bg - log(1 - meInt) / meDur

# recovery percentage (compared to diversity lost during ME)
reInt <- 1.1

# variations we want to test
reIntChange <- c(1.2, 1)

# speciation recovery rate
# such that we expect reInt * number alive at meStart
# to be alive at the end of the recovery period
lambda_re <- (log(reInt) - (lambda_bg - mu_me) * meDur) / reDur + mu_bg

# rates

# null model: rates are not trait dependent
lambda_null <- stepfun(c(reStart, reStart + reDur),
                       c(lambda_bg, lambda_re, lambda_bg))

mu_null <- stepfun(c(meStart, meStart + meDur),
                  c(mu_bg, mu_me, mu_bg))

# check how many species are expected by meStart + meDur + reDur
# number of living species at time t
expNt <- Vectorize(function(t) {
  exp(integrate(function(x) lambda_null(x) - mu_null(x), 0, t)$value)
})

# total number of species generated by time t
expTotalNt <- function(t) {
  integrate(function(x) lambda_null(x) * expNt(x), 0, t, 
            stop.on.error = FALSE)$value + 1
}

# find tMax such that the expected number of species is nExp
tMax <- uniroot(function(t) expTotalNt(t) - nExp, 
                c(meStart + meDur + reDur, meStart + meDur + reDur + 10),
                extendInt = "yes")$root

# bins - from the GSA time scale 
bins <- c(100, 93.9, 89.8, 83.6, 72.1, 66, 61.6, 56, 47.8, 41.2, 
          37.8, 33.9, 27.82, 23.03, 20.44, 15.97, 13.82, 
          11.63, 7.25, 5.33, 3.6, 0)

# tested model: rates are trait dependent

# speciation: increases with discrete trait during
# BG, modulated by continuous trait during RE

# extinction: modulated by continuous trait during
# BG, increases with discrete trait during ME

# continuous trait mean
bmX0 <- 0

# rough estimate of sigma2 for extant canines
bmSigma2 <- 0.021

# variations we want to test, +- 0.01
bmSigma2Change <- bmSigma2 + c(1, -1) * 0.01

# discrete trait starting state
stX0 <- 0

# function to find expected value of
# discrete trait given q01 and q10 at time t
expected.trait <- function(q01, q10, t) {
  q <- q01 + q10
  q01 / q - q01 / q * exp(- q * t)
}

# stQ01 and stQ10 were chosen so that
# 1. They sum to 0.025, 0.05 and 0.1 so we expect
# 1 change every 40, 20 and 10 my
# 2. They reach approximately the expected mean and
# variance from the empirical data set after 34my

# stQ01 and stQ10 for the baseline - intermediary values
stQ01 <- 0.0145
stQ10 <- 0.0355

# sum of values
stQSum <- stQ01 + stQ10

# values we wish to test
stQ01Change <- c(0.0245, 0.01)
stQSumChange <- c(0.1, 0.025)

# transition matrix
stQ <- matrix(c(0, stQ10, stQ01, 0), 2, 2)

# mean of t given m
meanLambda <- function(l) {
  exponent <- Vectorize(function(t, l) {
    integrate(function(x) l - l/5*expected.trait(stQ01, stQ10, x), 0, t)$value
  })
  
  integrate(function(t) t * (l - l/5 * expected.trait(stQ01, stQ10, t)) *
              exp(-exponent(t, l)), 0, Inf)$value
}

# l leading to 1 / lambda_bg
lambda_bg_0 <- uniroot(function(l) meanLambda(l) - 1/lambda_bg, 
                       interval = c(0.1, 1))$root

# lambda_re decreases by 15% with one
# unit of body size away from optimum
lambdaModCont <- 0.15

# define lambda such that the expected value during 
# BG is lambda_bg, and during RE is lambda_re
lambda <- function(t, traits) {
  reStart <- meStart + meDur
  reEnd <- reStart + reDur
  ifelse((t < reStart) || (t > reEnd),                    
         # BG
         lambda_bg_0 - lambda_bg_0/5* traits[2],
         # RE
         lambda_re + lambdaModCont * lambda_re * traits[1])
}
# in other words, E[lambda] = lambda_null

# mean of t given m
meanMu <- function(m) {
  exponent <- Vectorize(function(t, m) {
    integrate(function(x) m - m/5*expected.trait(stQ01, stQ10, x), 0, t)$value
  })
  
  integrate(function(t) t * (m - m/5 * expected.trait(stQ01, stQ10, t)) *
              exp(-exponent(t, m)), 0, Inf)$value
}

# m leading to 1 / mu_me
mu_me_0 <- uniroot(function(m) meanMu(m) - 1/mu_me, 
                       interval = c(0.1, 1))$root

# mu_bg increases by 15% with one
# unit of body size away from optimum
muModCont <- 0.15

# define mu such that the expected value during
# BG is mu_bg, and during ME is mu_me
mu <- function(t, traits) {
  ifelse((t < meStart) || (t > meStart + meDur),
         # BG
         mu_bg + muModCont * mu_bg  * traits[1],
         # ME
         mu_me_0 - mu_me_0/5 * traits[2])
}
# in other words, E[mu] = mu_null

# number of reps to run each combination of parameters
nReps <- 50

###
# create directories for saving data

# make a smarter dir.create function
smart.dir.create <- function(dir) {
  if (!dir.exists(dir)) dir.create(dir)
}

###
# consider parameter changes and run simulations

# collect baseline parameters in a data
# frame that will later become the key

key <- data.frame(ref = "base",
                  meDur = meDur,
                  reDur = reDur,
                  meInt = meInt, 
                  reInt = reInt,
                  bmSigma2 = bmSigma2,
                  stQ01 = stQ01,
                  stQSum = stQSum,
                  lambdaModCont = lambdaModCont,
                  muModCont = muModCont)

# make a vector to hold the baseline parameters
base <- key[1, ]

# reference vector for each parameter change
refs <- c("longME", "shortME", "longRE", "shortRE", "hIntME", "lIntME", 
          "hIntRE", "lIntME", "highVar", "lowVar", "highSum", "lowSum")

# the corresponding column numbers to change in the base
change <- c(2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7)

# the new values
new <- c(meDurChange, reDurChange, meIntChange, 
         reIntChange, bmSigma2Change, stQ01Change)

# copy the baseline a bunch of times to fill the key
key <- rbind(key, key[rep(1, length(change)), ])
rownames(key) <- 1:nrow(key)

# populate it with the values in aux
for (i in 2:nrow(key)) {
  key$ref[i] <- refs[i - 1]
  key[i, change[i - 1]] <- new[i - 1]
}

# change stQSum values
key[key$ref == "highSum", ]$stQSum <- stQSumChange[1]
key[key$ref == "lowSum", ]$stQSum <- stQSumChange[2]

###
# auxiliary functions

# make a make.phylo output usable by FBD in RevBayes
# credit: Joshua Justison
collapseFossils <- function(tree) {
  # number of tips in the original tree
  nTips <- length(tree$tip.label)
  
  # indices to delete - edges with length 0
  delInd <- tree$edge.length == 0
  
  # tips to delete
  deletedTips<- tree$edge[delInd, 2]
  
  # get the labels of the deleted tips
  internalLabels <- tree$tip.label[deletedTips]
  
  # node numbers for the tips we are deleting
  nodeNumbers <- tree$edge[delInd, 1]
  
  # drop tips, but keep them as nodes
  tree <- drop.tip(tree, deletedTips, collapse.singles = FALSE)
  
  # reset node labels
  tree$node.label <- rep("", rep(tree$Nnode))
  
  # add previous deleted tips' labels to the new nodes
  tree$node.label[nodeNumbers - nTips] <- internalLabels
  
  return(tree)
}

###
# write simulation functions

# minimum number of sampled species
# 1/2 of minimum number of species
minSamp <- nMin / 2

# minimum mean number of fossil occurrences 
minFossils <- nMin * 2

# and maximum 
maxFossils <- nMax * 2

# create simulation function for one rep
simulate_rep <- function(comb, tMax, lambda, mu, nFinal, rho, bins,
                             bmSigma2, bmX0, stQ, stX0) {
  # set up test so while loop runs
  bounds <- FALSE
  
  # create pars list
  pars <- list("BM" = list("X0" = bmX0, "sigma2" = bmSigma2),
               "ST" = list("states" = list(c(0, 1)), 
                           "X0" = stX0, "Q" = list(stQ)))
  
  # counter to make sure we don't have to repeat too many times
  counter <- 1
  
  # while out of bounds
  while (!bounds) {
    # run simulation 
    sim <- bd.sim.traits(1, lambda, mu, tMax, nTraits = 2,
                         traitModel = c("BM", "ST"), pars = pars,
                         nFinal = nFinal, nExtant = nExtant)
    
    # get trait function lists
    traitCont <- lapply(1:length(sim$TRAITS), function(x) 
      sim$TRAITS[[x]]$trait1)
    traitDisc <- lapply(1:length(sim$TRAITS), function(x) 
      sim$TRAITS[[x]]$trait2)
    
    # name them
    names(traitCont) <- names(traitDisc) <- paste0("t", 1:length(sim$SIM$TS))
    
    # and get the sim object
    sim <- sim$SIM
    
    # sample test
    sampleBounds <- FALSE
    
    # run until in bounds
    while (!sampleBounds) {
      # get fossil samples
      sample <- data.frame()
      while (nrow(sample) == 0) {
        sample <- suppressMessages(sample.clade(sim, rho, tMax, 
                                                bins = bins, returnAll = TRUE))
      }
      
      # number of sampled species
      nSampled <- length(unique(sample$Species))
      
      # test
      sampleBounds <- nrow(sample) >= minFossils &&
        nrow(sample) <= maxFossils
    }
    
    # make a molecular tree
    tree <- drop.fossil(make.phylo(sim))
	
    # and an SA tree
    # remembering to drop extinct taxa and keep only the fossils
    saTree <- drop.tip(make.phylo(sim, sample), 
                       tip = paste0("t", which(!sim$EXTANT)))
    
    # get a list of taxa for tree and SAtree
    treeTaxa <- as.numeric(unlist(lapply(tree$tip.label, 
                                           function(x) sub("t", "", x))))
    saTreeTaxa <- as.numeric(unlist(lapply(saTree$tip.label, 
                                           function(x) sub("t", "", x))))
    
    # get an fbd tree with SAs collapsed as nodes with degree 2
    fbdTree <- collapseFossils(saTree)
    
    # times to sample traits from the saTree taxa
    saTreeTraitSampT <- 
      lapply(saTreeTaxa,
             function(x)
               ifelse(x == floor(x), tMax, tMax - 
                        sample[sample$Species == 
                                 paste0("t", floor(x)), 
                               "SampT"][round(10*(x - floor(x)))]))
    # the present for extant species, sampling time for fossils
    
    # name it
    names(saTreeTraitSampT) <- paste0("t", saTreeTaxa)
    
    # and make the trait lists
    # for the tree
    treeTraitsCont <- as.numeric(unlist(lapply(treeTaxa, 
                                               function(x)
                                                traitCont[[paste0("t", x)]](
                                                   tMax
                                                ))))
    
    names(treeTraitsCont) <- paste0("t", treeTaxa)
    
    treeTraitsDisc <- as.numeric(unlist(lapply(treeTaxa, 
                                               function(x)
                                              traitDisc[[paste0("t", x)]](
                                                tMax
                                              ))))
    
    names(treeTraitsDisc) <- paste0("t", treeTaxa)
    
    # and the saTree
    saTreeTraitsCont <- as.numeric(unlist(lapply(saTreeTaxa,
                                                 function(x)
                                        traitCont[[paste0("t", floor(x))]](
                                          saTreeTraitSampT[[paste0("t", x)]]
                                        ))))
    
    names(saTreeTraitsCont) <- paste0("t", saTreeTaxa)
    
    saTreeTraitsDisc <- as.numeric(unlist(lapply(saTreeTaxa,
                                                 function(x)
                                        traitDisc[[paste0("t", floor(x))]](
                                          saTreeTraitSampT[[paste0("t", x)]]
                                        ))))
    
    
    names(saTreeTraitsDisc) <- paste0("t", saTreeTaxa)
    
    # and sum of discrete traits - we want there to be at least 5 of each
    sumDisc <- sum(treeTraitsDisc)
    
    # checks
    bounds <- (nSampled >= minSamp) &&
      (sumDisc >= 5) &&
      (sumDisc <= (length(treeTaxa) - 5))
    
    # if counter is higher than 10, maybe rethink the parameters
    if (counter > 10) stop("Hard to find replicate within bounds")
  }
  
  # make a list to return
  res <- list(SIM = sim, SAMPLE = sample, 
              TREE = tree, SATREE = saTree, FBDTREE = fbdTree,
              TRAITFUNCC = traitCont, TRAITFUNCD = traitDisc,
              TRAITSC = treeTraitsCont, TRAITSD = treeTraitsDisc,
              SATRAITSC = saTreeTraitsCont, SATRAITSD = saTreeTraitsDisc)
  
  return(res)
}

# function to save simulation lists
save_sims <- function(simReps, targetDir) {
  # extract simulations and trait functions
  simList <- lapply(1:nReps, function(x) simReps[[x]]$SIM)
  bmTraitsFunc <- lapply(1:nReps, function(x) simReps[[x]]$TRAITFUNCC)
  stTraitsFunc <- lapply(1:nReps, function(x) simReps[[x]]$TRAITFUNCD)

  # save simulation RData
  save(simList, file = paste0(targetDir, "sim_list.RData"))
  
  # simulations directory
  simsDir <- paste0(targetDir, "sims/")
  smart.dir.create(simsDir)
  
  # trait lists directory
  traitListDir <- paste0(targetDir, "trait_lists/")
  smart.dir.create(traitListDir)
  
  # fossils directory
  fossilsDir <- paste0(targetDir, "fossils/")
  smart.dir.create(fossilsDir)
  
  # and tree directory
  treeDir <- paste0(targetDir, "trees/")
  smart.dir.create(treeDir)
  
  # print simulations to file
  invisible(lapply(1:nReps, function(x)
    capture.output(print(simList[[x]]),
                   file = paste0(simsDir, "sim_", x, ".txt"))))
  invisible(lapply(1:nReps, function(x)
    capture.output(lapply(simList[[x]], function(x) {
      cat("\n")
      x}),
      file = paste0(simsDir, "sim_", x, ".txt"),
      append = TRUE))) 
  
  # and trait RData
  save(bmTraitsFunc, file = paste0(targetDir, "bm_traits.RData"))
  save(stTraitsFunc, file = paste0(targetDir, "st_traits.RData"))

  # get trait lists
  # for molecular trees
  bmMolTraitList <- lapply(1:nReps, function(x) simReps[[x]]$TRAITSC)
  stMolTraitList <- lapply(1:nReps, function(x) simReps[[x]]$TRAITSD)
  
  # and SA trees
  bmSATraitList <- lapply(1:nReps, function(x) simReps[[x]]$SATRAITSC)
  stSATraitList <- lapply(1:nReps, function(x) simReps[[x]]$SATRAITSD)
  
  # save them as .nex
  invisible(lapply(1:nReps, function(x)
    write.nexus.data(bmMolTraitList[[x]], 
                     file = paste0(traitListDir, "bm_mol_traits_", x, ".nex"),
                     format = "continuous")))
  invisible(lapply(1:nReps, function(x)
    write.nexus.data(stMolTraitList[[x]], 
                     file = paste0(traitListDir, "st_mol_traits_", x, ".nex"),
                     format = "standard")))
  
  invisible(lapply(1:nReps, function(x)
    write.nexus.data(bmSATraitList[[x]], 
                     file = paste0(traitListDir, "bm_SA_traits_", x, ".nex"),
                     format = "continuous")))
  invisible(lapply(1:nReps, function(x)
    write.nexus.data(stSATraitList[[x]], 
                     file = paste0(traitListDir, "st_SA_traits_", x, ".nex"),
                     format = "standard")))
  
  # get fossil records
  fossilsList <- lapply(1:nReps, function(x) simReps[[x]]$SAMPLE)
  
  # save fossil records as tsv
  invisible(lapply(1:nReps, function(x)
    write_tsv(fossilsList[[x]], paste0(fossilsDir, "fossils_", 
                                       x, ".tsv"))))
  
  # get trees
  treeList <-  lapply(1:nReps, function(x) simReps[[x]]$TREE)
  
  # save trees as .nex
  lapply(1:nReps, function(x)
    write.nexus(treeList[[x]], file = paste0(treeDir, "tree_",
                                             x, ".nex")))

  # and same for saTrees
  saTreeListNull <-  lapply(1:nReps, function(x) simReps[[x]]$SATREE)
  
  lapply(1:nReps, function(x)
    write.nexus(saTreeListNull[[x]], file = paste0(treeDir, "saTree_",
                                                   x, ".nex")))

  # aaand fbd trees
  fbdTreeList <-  lapply(1:nReps, function(x) simReps[[x]]$FBDTREE)
  
  lapply(1:nReps, function(x)
    write.nexus(fbdTreeList[[x]], file = paste0(treeDir, "fbdTree_",
                                                x, ".nex")))
}

# create function to run simulations 
# for a list of parameters
simulate <- function(nReps, comb, key, simDir) {
  ## recover parameters from key
  pars <- key[comb, ]
  
  meDur <- pars[["meDur"]]
  
  reStart <- meStart + meDur
  
  reDur <- pars[["reDur"]]
  
  meInt <- pars[["meInt"]]
  
  mu_me <- lambda_bg - log(1 - meInt) / meDur
  
  reInt <- pars[["reInt"]]
  
  lambda_re <- (log(reInt) - (lambda_bg - mu_me) * meDur) / reDur + mu_bg
  
  lambda_null <- stepfun(c(reStart, reStart + reDur),
                         c(lambda_bg, lambda_re, lambda_bg))
  
  mu_null <- stepfun(c(meStart, meStart + meDur),
                     c(mu_bg, mu_me, mu_bg))
  
  expNt <- Vectorize(function(t) {
    exp(integrate(function(x) lambda_null(x) - mu_null(x), 0, t)$value)
  })
  
  expTotalNt <- function(t) {
    integrate(function(x) lambda_null(x) * expNt(x), 0, t, 
              stop.on.error = FALSE)$value + 1
  }
  
  tMax <- uniroot(function(t) expTotalNt(t) - nExp, 
                  c(meStart + meDur + reDur, 
                    meStart + meDur + reDur + 10),
                  extendInt = "yes")$root
  
  bmSigma2 <- pars[["bmSigma2"]]
  
  stQ01 <- pars[["stQ01"]]
  stQ10 <- pars[["stQSum"]] - stQ01
  
  stQ <- matrix(c(0, stQ10, stQ01, 0), 2, 2)
  
  meanLambda <- function(l) {
    exponent <- Vectorize(function(t, l) {
      integrate(function(x) l - l/5*
                  expected.trait(stQ01, stQ10, x), 0, t)$value
    })
    
    integrate(function(t) t * (l - l/5 * expected.trait(stQ01, stQ10, t)) *
                exp(-exponent(t, l)), 0, Inf)$value
  }
  
  lambda_bg_0 <- uniroot(function(l) meanLambda(l) - 1/lambda_bg, 
                         interval = c(0.1, 1),
                         extendInt = "yes")$root
  
  lambdaModCont <- pars[["lambdaModCont"]]
  
  lambda <- function(t, traits) {
    reStart <- meStart + meDur
    reEnd <- reStart + reDur
    ifelse((t < reStart) || (t > reEnd),                    
           # BG
           lambda_bg_0 - lambda_bg_0/5 * traits[2],
           # RE
           lambda_re + lambdaModCont * lambda_re * traits[1])
  }
  
  meanMu <- function(m) {
    exponent <- Vectorize(function(t, m) {
      integrate(function(x) m - m/5*
                  expected.trait(stQ01, stQ10, x), 0, t)$value
    })
    
    integrate(function(t) t * (m - m/5 * expected.trait(stQ01, stQ10, t)) *
                exp(-exponent(t, m)), 0, Inf)$value
  }
  
  mu_me_0 <- uniroot(function(m) meanMu(m) - 1/mu_me, 
                     interval = c(0.1, 1),
                     extendInt = "yes")$root
  
  muModCont <- pars[["muModCont"]]
  
  mu <- function(t, traits) {
    ifelse((t < meStart) || (t > meStart + meDur),
           # BG
           mu_bg + muModCont * mu_bg  * traits[1],
           # ME
           mu_me_0 - mu_me_0/5 * traits[2])
  }
  
  ## create directories
  
  # base directory for simulations with parameter combination comb
  combDir <- paste0(simDir, "comb_", comb, "/")
  smart.dir.create(combDir)
  
  # null directory
  nullDir <- paste0(combDir, "null/")
  smart.dir.create(nullDir)
  
  # trait sims directory
  traitsDir <- paste0(combDir, "traits/")
  smart.dir.create(traitsDir)
  
  ## run simulations
  seed <- .Random.seed
  write.table(seed, file = paste0(combDir, "seed_", comb, ".txt"))

  # run null simulations
  simRepsNull <- lapply(1:nReps, function(x) {
    print(paste0("comb: ", comb, " null: ", x))
    simulate_rep(comb, tMax, lambda_null, mu_null, nFinal, rho, bins,
                 bmSigma2, bmX0, stQ, stX0)
    })
  
  # save them
  invisible(save_sims(simRepsNull, nullDir))
  
  # run trait simulations
  simTraitsReps <- lapply(1:nReps, function(x) {
    print(paste0("comb: ", comb, " trait: ", x))
    simulate_rep(comb, tMax, lambda, mu, nFinal, rho, bins,
                 bmSigma2, bmX0, stQ, stX0)
  })
  
  # save them
  invisible(save_sims(simTraitsReps, traitsDir))
}
